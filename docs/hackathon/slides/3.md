# Building transactions with Pallas

Library provides primitives, (de)serialization, building and signing. It does not provide balancing and fee calculation. It provides a local `validate_tx` function that operates without an external Cardano Node.

- Fee calculation using `(tx_size * minfee_a) + minfee_b`
- Script fees using max CPU and memory units

```rust
let input = address_utxo_to_input(utxo_to_spend);
let output = Output::new(
    &config.wallet_address,
    utxo_to_spend.lovelace() - fee,
);

StagingTransaction::new()
  .fee(fee)
  .input(utxo_to_spend.into())
  .output(output)
  .change_address(address.clone())
  .network_id(config.network.clone().into())
  .collateral_input(address_utxo_to_input(utxo_to_spend))
  // Collateral outputs are a CIP-40 feature. We don't need them for now.
  // .collateral_output(output);
  .disclosed_signer(address_payment_key_hash(address))
```

As part of this, we also used the protocol parameters implementation from [dolos](https://github.com/txpipe/dolos) for tx validation via `validate_tx`. This means we can load Cardano Node's config files.

```rust
pub fn get_protocol_parameters(network: NetworkId) -> anyhow::Result<MultiEraProtocolParameters> {
    let network = match network {
        NetworkId::Mainnet => "mainnet",
        NetworkId::Testnet => "preview",
    };
    let root = PathBuf::from(format!("configs/{network}"));
    let shelley = shelley::from_file(&root.join("shelley.json"))?;
    let alonzo = alonzo::from_file(&root.join("alonzo.json"))?;
    let conway = conway::from_file(&root.join("conway.json"))?;

    let shelley_params = bootstrap_shelley_pparams(&shelley);
    let alonzo_params = bootstrap_alonzo_pparams(shelley_params, &alonzo);
    let babbage_params = bootstrap_babbage_pparams(alonzo_params);
    let conway_params = bootstrap_conway_pparams(babbage_params, &conway);

    Ok(MultiEraProtocolParameters::Conway(conway_params))
}
```

## Future work

- Use cost model for script fee calculation to reduce fees
  - Use `cardano-serialization-lib` for reference, seems difficult, need to measure impact
- Add automatic balancing (trivial for our cases)
  - Use `cardano-serialization-lib` for reference, doesn't seem difficult
- Wrap in an builder pattern API
